const Br=function(){const Ge=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(n){n=n||{};var n=typeof n<"u"?n:{};let ne={},U;for(U in n)n.hasOwnProperty(U)&&(ne[U]=n[U]);let he=function(e,t){throw t},re=!1,k=!1,Me=!1,qe=!1,Je=!1;if(re=typeof window=="object",k=typeof importScripts=="function",qe=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Me=qe&&!re&&!k,Je=!re&&!Me&&!k,n.ENVIRONMENT)throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)");let M="";function xt(e){return n.locateFile?n.locateFile(e,M):M+e}let Te,ie;if(Me){M=`${__dirname}/`;let e,t;Te=function(i,o){let a;return e||(e=require(["fs"].join())),t||(t=require(["path"].join())),i=t.normalize(i),a=e.readFileSync(i),o?a:a.toString()},ie=function(i){let o=Te(i,!0);return o.buffer||(o=new Uint8Array(o)),f(o.buffer),o},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",r=>{if(!(r instanceof It))throw r}),process.on("unhandledRejection",c),he=function(r){process.exit(r)},n.inspect=function(){return"[Emscripten Module object]"}}else if(Je)typeof read<"u"&&(Te=function(t){return read(t)}),ie=function(t){let r;return typeof readbuffer=="function"?new Uint8Array(readbuffer(t)):(r=read(t,"binary"),f(typeof r=="object"),r)},typeof scriptArgs<"u"&&scriptArgs,typeof quit=="function"&&(he=function(e){quit(e)}),typeof print<"u"&&(typeof console>"u"&&(console={}),console.log=print,console.warn=console.error=typeof printErr<"u"?printErr:print);else if(re||k)k?M=self.location.href:document.currentScript&&(M=document.currentScript.src),Ge&&(M=Ge),M.indexOf("blob:")!==0?M=M.substr(0,M.lastIndexOf("/")+1):M="",Te=function(t){const r=new XMLHttpRequest;return r.open("GET",t,!1),r.send(null),r.responseText},k&&(ie=function(t){const r=new XMLHttpRequest;return r.open("GET",t,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)});else throw new Error("environment detection error");let oe=n.print||function(){},m=n.printErr||function(){};for(U in ne)ne.hasOwnProperty(U)&&(n[U]=ne[U]);ne=null,n.arguments&&n.arguments,Object.getOwnPropertyDescriptor(n,"arguments")||Object.defineProperty(n,"arguments",{configurable:!0,get(){c("Module.arguments has been replaced with plain arguments_")}}),n.thisProgram&&n.thisProgram,Object.getOwnPropertyDescriptor(n,"thisProgram")||Object.defineProperty(n,"thisProgram",{configurable:!0,get(){c("Module.thisProgram has been replaced with plain thisProgram")}}),n.quit&&(he=n.quit),Object.getOwnPropertyDescriptor(n,"quit")||Object.defineProperty(n,"quit",{configurable:!0,get(){c("Module.quit has been replaced with plain quit_")}}),f(typeof n.memoryInitializerPrefixURL>"u","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"),f(typeof n.pthreadMainPrefixURL>"u","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"),f(typeof n.cdInitializerPrefixURL>"u","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"),f(typeof n.filePackagePrefixURL>"u","Module.filePackagePrefixURL option was removed, use Module.locateFile instead"),f(typeof n.read>"u","Module.read option was removed (modify read_ in JS)"),f(typeof n.readAsync>"u","Module.readAsync option was removed (modify readAsync in JS)"),f(typeof n.readBinary>"u","Module.readBinary option was removed (modify readBinary in JS)"),f(typeof n.setWindowTitle>"u","Module.setWindowTitle option was removed (modify setWindowTitle in JS)"),Object.getOwnPropertyDescriptor(n,"read")||Object.defineProperty(n,"read",{configurable:!0,get(){c("Module.read has been replaced with plain read_")}}),Object.getOwnPropertyDescriptor(n,"readAsync")||Object.defineProperty(n,"readAsync",{configurable:!0,get(){c("Module.readAsync has been replaced with plain readAsync")}}),Object.getOwnPropertyDescriptor(n,"readBinary")||Object.defineProperty(n,"readBinary",{configurable:!0,get(){c("Module.readBinary has been replaced with plain readBinary")}}),Ye=$t=Ve=function(){c("cannot use the stack before compiled code is ready to run, and has provided stack access")};function I(e){I.shown||(I.shown={}),I.shown[e]||(I.shown[e]=1,m(e))}const Xt={"f64-rem"(e,t){return e%t},debugger(){debugger}};new Array(0);const kt=function(e){};let ae;n.wasmBinary&&(ae=n.wasmBinary),Object.getOwnPropertyDescriptor(n,"wasmBinary")||Object.defineProperty(n,"wasmBinary",{configurable:!0,get(){c("Module.wasmBinary has been replaced with plain wasmBinary")}});let Se;n.noExitRuntime&&(Se=n.noExitRuntime),Object.getOwnPropertyDescriptor(n,"noExitRuntime")||Object.defineProperty(n,"noExitRuntime",{configurable:!0,get(){c("Module.noExitRuntime has been replaced with plain noExitRuntime")}}),typeof WebAssembly!="object"&&c("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.");let j;const jt=new WebAssembly.Table({initial:352,maximum:352,element:"anyfunc"});let Ee=!1;function f(e,t){e||c(`Assertion failed: ${t}`)}function Lt(e){const t=n[`_${e}`];return f(t,`Cannot call unknown function ${e}, make sure it is exported`),t}function Ke(e,t,r,i,o){const a={string(p){let y=0;if(p!=null&&p!==0){const O=(p.length<<2)+1;y=Ve(O),ge(p,y,O)}return y},array(p){const y=Ve(p.length);return Bt(p,y),y}};function u(p){return t==="string"?L(p):t==="boolean"?!!p:p}const s=Lt(e),l=[];let d=0;if(f(t!=="array",'Return type should not be "array".'),i)for(let p=0;p<i.length;p++){const y=a[r[p]];y?(d===0&&(d=Ye()),l[p]=y(i[p])):l[p]=i[p]}let _=s.apply(null,l);return _=u(_),d!==0&&$t(d),_}function Ht(e,t,r,i){return function(){return Ke(e,t,r,arguments)}}const Ze=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function et(e,t,r){const i=t+r;let o=t;for(;e[o]&&!(o>=i);)++o;if(o-t>16&&e.subarray&&Ze)return Ze.decode(e.subarray(t,o));let a="";for(;t<o;){let u=e[t++];if(!(u&128)){a+=String.fromCharCode(u);continue}const s=e[t++]&63;if((u&224)==192){a+=String.fromCharCode((u&31)<<6|s);continue}const l=e[t++]&63;if((u&240)==224?u=(u&15)<<12|s<<6|l:((u&248)!=240&&I(`Invalid UTF-8 leading byte 0x${u.toString(16)} encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!`),u=(u&7)<<18|s<<12|l<<6|e[t++]&63),u<65536)a+=String.fromCharCode(u);else{const d=u-65536;a+=String.fromCharCode(55296|d>>10,56320|d&1023)}}return a}function L(e,t){return e?et(w,e,t):""}function Qt(e,t,r,i){if(!(i>0))return 0;const o=r,a=r+i-1;for(let u=0;u<e.length;++u){let s=e.charCodeAt(u);if(s>=55296&&s<=57343){const l=e.charCodeAt(++u);s=65536+((s&1023)<<10)|l&1023}if(s<=127){if(r>=a)break;t[r++]=s}else if(s<=2047){if(r+1>=a)break;t[r++]=192|s>>6,t[r++]=128|s&63}else if(s<=65535){if(r+2>=a)break;t[r++]=224|s>>12,t[r++]=128|s>>6&63,t[r++]=128|s&63}else{if(r+3>=a)break;s>=2097152&&I(`Invalid Unicode code point 0x${s.toString(16)} encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).`),t[r++]=240|s>>18,t[r++]=128|s>>12&63,t[r++]=128|s>>6&63,t[r++]=128|s&63}}return t[r]=0,r-o}function ge(e,t,r){return f(typeof r=="number","stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"),Qt(e,w,t,r)}function tt(e){let t=0;for(let r=0;r<e.length;++r){let i=e.charCodeAt(r);i>=55296&&i<=57343&&(i=65536+((i&1023)<<10)|e.charCodeAt(++r)&1023),i<=127?++t:i<=2047?t+=2:i<=65535?t+=3:t+=4}return t}typeof TextDecoder<"u"&&new TextDecoder("utf-16le");function Bt(e,t){f(e.length>=0,"writeArrayToMemory array must have a length (should be an array or typed array)"),z.set(e,t)}const nt=65536;function rt(e,t){return e%t>0&&(e+=t-e%t),e}let H,z,w,De,ve,F,P,it,ot;function at(e){H=e,n.HEAP8=z=new Int8Array(e),n.HEAP16=De=new Int16Array(e),n.HEAP32=F=new Int32Array(e),n.HEAPU8=w=new Uint8Array(e),n.HEAPU16=ve=new Uint16Array(e),n.HEAPU32=P=new Uint32Array(e),n.HEAPF32=it=new Float32Array(e),n.HEAPF64=ot=new Float64Array(e)}const Wt=434112,G=5676992,st=5676992,Vt=433920;f(Wt%16===0,"stack must start aligned"),f(st%16===0,"heap must start aligned");const $e=5242880;n.TOTAL_STACK&&f($e===n.TOTAL_STACK,"the stack size can no longer be determined at runtime");let se=n.TOTAL_MEMORY||16777216;Object.getOwnPropertyDescriptor(n,"TOTAL_MEMORY")||Object.defineProperty(n,"TOTAL_MEMORY",{configurable:!0,get(){c("Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY")}}),f(se>=$e,`TOTAL_MEMORY should be larger than TOTAL_STACK, was ${se}! (TOTAL_STACK=${$e})`),f(typeof Int32Array<"u"&&typeof Float64Array<"u"&&Int32Array.prototype.subarray!==void 0&&Int32Array.prototype.set!==void 0,"JS engine does not provide full typed array support"),n.wasmMemory?j=n.wasmMemory:j=new WebAssembly.Memory({initial:se/nt}),j&&(H=j.buffer),se=H.byteLength,f(se%nt===0),at(H),F[Vt>>2]=st;function ct(){f((G&3)==0),P[(G>>2)-1]=34821223,P[(G>>2)-2]=2310721022,F[0]=1668509029}function q(){const e=P[(G>>2)-1],t=P[(G>>2)-2];(e!=34821223||t!=2310721022)&&c(`Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x${t.toString(16)} ${e.toString(16)}`),F[0]!==1668509029&&c("Runtime error: The application has corrupted its heap memory area (address zero)!")}function ut(e){c(`Stack overflow! Attempted to allocate ${e} bytes on the stack, but stack has only ${G-Ye()+e} bytes available!`)}(function(){const e=new Int16Array(1),t=new Int8Array(e.buffer);if(e[0]=25459,t[0]!==115||t[1]!==99)throw"Runtime error: expected the system to be little-endian!"})();function R(e,t){c(`Invalid function pointer ${e} called with signature '${t}'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.`)}function me(e){for(;e.length>0;){const t=e.shift();if(typeof t=="function"){t();continue}const r=t.func;typeof r=="number"?t.arg===void 0?n.dynCall_v(r):n.dynCall_vi(r,t.arg):r(t.arg===void 0?null:t.arg)}}const lt=[],ft=[],Yt=[],dt=[];let T=!1,E=!1;function zt(){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)Zt(n.preRun.shift());me(lt)}function Gt(){q(),f(!T),T=!0,me(ft)}function qt(){q(),me(Yt)}function Jt(){q(),E=!0}function Kt(){if(q(),n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;)en(n.postRun.shift());me(dt)}function Zt(e){lt.unshift(e)}function en(e){dt.unshift(e)}f(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),f(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),f(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),f(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");let Q=0,B=null,ce=null;const ue={};function tn(e){Q++,n.monitorRunDependencies&&n.monitorRunDependencies(Q),f(!ue[e]),ue[e]=1,B===null&&typeof setInterval<"u"&&(B=setInterval(()=>{if(Ee){clearInterval(B),B=null;return}let t=!1;for(const r in ue)t||(t=!0,m("still waiting on run dependencies:")),m(`dependency: ${r}`);t&&m("(end of list)")},1e4))}function nn(e){if(Q--,n.monitorRunDependencies&&n.monitorRunDependencies(Q),f(ue[e]),delete ue[e],Q==0&&(B!==null&&(clearInterval(B),B=null),ce)){const t=ce;ce=null,t()}}n.preloadedImages={},n.preloadedAudios={};function c(e){n.onAbort&&n.onAbort(e),e+="",oe(e),m(e),Ee=!0;const t="";throw`abort(${e}) at ${un()}${t}`}var g={error(){c("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1")},init(){g.error()},createDataFile(){g.error()},createPreloadedFile(){g.error()},createLazyFile(){g.error()},open(){g.error()},mkdev(){g.error()},registerDevice(){g.error()},analyzePath(){g.error()},loadFilesFromDB(){g.error()},ErrnoError:function(){g.error()}};n.FS_createDataFile=g.createDataFile,n.FS_createPreloadedFile=g.createPreloadedFile;const pt="data:application/octet-stream;base64,";function _t(e){return String.prototype.startsWith?e.startsWith(pt):e.indexOf(pt)===0}let x="woff2.wasm";_t(x)||(x=xt(x));function yt(){try{if(ae)return new Uint8Array(ae);if(ie)return ie(x);throw"both async and sync fetching of the wasm failed"}catch(e){c(e)}}function rn(){return!ae&&(re||k)&&typeof fetch=="function"?fetch(x,{credentials:"same-origin"}).then(e=>{if(!e.ok)throw`failed to load wasm binary file at '${x}'`;return e.arrayBuffer()}).catch(()=>yt()):new Promise((e,t)=>{e(yt())})}function on(){const e={env:Be,wasi_unstable:Be,global:{NaN:NaN,Infinity:1/0},"global.Math":Math,asm2wasm:Xt};function t(u,s){const l=u.exports;n.asm=l,nn("wasm-instantiate")}tn("wasm-instantiate");let r=n;function i(u){f(n===r,"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"),r=null,t(u.instance)}function o(u){return rn().then(s=>WebAssembly.instantiate(s,e)).then(u,s=>{m(`failed to asynchronously prepare wasm: ${s}`),c(s)})}function a(){if(!ae&&typeof WebAssembly.instantiateStreaming=="function"&&!_t(x)&&typeof fetch=="function"&&typeof process=="object"&&process.versions&&process.versions.node&&+process.versions.node.split(".")[0]<17)fetch(x,{credentials:"same-origin"}).then(u=>WebAssembly.instantiateStreaming(u,e).then(i,l=>{m(`wasm streaming compile failed: ${l}`),m("falling back to ArrayBuffer instantiation"),o(i)}));else return o(i)}if(n.instantiateWasm)try{return n.instantiateWasm(e,t)}catch(u){return m(`Module.instantiateWasm callback failed with error: ${u}`),!1}return a(),{}}n.asm=on,ft.push({func(){kr()}}),f(434096%8==0);function an(e){const t=n.___cxa_demangle||n.__cxa_demangle;f(t);try{let a=e;a.startsWith("__Z")&&(a=a.substr(1));const u=tt(a)+1;var r=_e(u);ge(a,r,u);var i=_e(4),o=t(r,0,0,i);if(F[i>>2]===0&&o)return L(o)}catch{}finally{r&&v(r),i&&v(i),o&&v(o)}return e}function sn(e){const t=/\b__Z[\w\d_]+/g;return e.replace(t,r=>{const i=an(r);return r===i?r:`${i} [${r}]`})}function cn(){let e=new Error;if(!e.stack){try{throw new Error(0)}catch(t){e=t}if(!e.stack)return"(no stack trace available)"}return e.stack.toString()}function un(){let e=cn();return n.extraStackTrace&&(e+=`
${n.extraStackTrace()}`),sn(e)}function ln(e,t,r,i){c(`Assertion failed: ${L(e)}, at: ${[t?L(t):"unknown filename",r,i?L(i):"unknown function"]}`)}function fn(e){return _e(e)}function dn(e,t,r){throw"uncaught_exception"in We?We.uncaught_exceptions++:We.uncaught_exceptions=1,`${e} - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.`}function pn(){}function _n(){}var S={buffers:[null,[],[]],printChar(e,t){const r=S.buffers[e];f(r),t===0||t===10?((e===1?oe:m)(et(r,0)),r.length=0):r.push(t)},varargs:0,get(e){return S.varargs+=4,F[S.varargs-4>>2]},getStr(){return L(S.get())},get64(){const e=S.get(),t=S.get();return e>=0?f(t===0):f(t===-1),e},getZero(){f(S.get()===0)}};function yn(e){try{return c("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM"),0}catch(t){return(typeof g>"u"||!(t instanceof g.ErrnoError))&&c(t),t.errno}}function hn(){return yn.apply(null,arguments)}function Tn(e,t,r,i,o){try{return c("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM"),0}catch(a){return(typeof g>"u"||!(a instanceof g.ErrnoError))&&c(a),a.errno}}function En(){return Tn.apply(null,arguments)}function gn(){const e=n._fflush;e&&e(0);const t=S.buffers;t[1].length&&S.printChar(1,10),t[2].length&&S.printChar(2,10)}function mn(e,t,r,i){try{let o=0;for(let a=0;a<r;a++){const u=F[t+a*8>>2],s=F[t+(a*8+4)>>2];for(let l=0;l<s;l++)S.printChar(e,w[u+l]);o+=s}return F[i>>2]=o,0}catch(o){return(typeof g>"u"||!(o instanceof g.ErrnoError))&&c(o),o.errno}}function wn(){return mn.apply(null,arguments)}function Ie(e){switch(e){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(`Unknown type size: ${e}`)}}function On(){const e=new Array(256);for(let t=0;t<256;++t)e[t]=String.fromCharCode(t);ht=e}var ht=void 0;function A(e){let t="",r=e;for(;w[r];)t+=ht[w[r++]];return t}const J={},W={},we={},bn=48,Rn=57;function Ce(e){if(e===void 0)return"_unknown";e=e.replace(/[^a-zA-Z0-9_]/g,"$");const t=e.charCodeAt(0);return t>=bn&&t<=Rn?`_${e}`:e}function Ne(e,t){return e=Ce(e),new Function("body",`return function ${e}() {
    "use strict";    return body.apply(this, arguments);
};
`)(t)}function Ue(e,t){const r=Ne(t,function(i){this.name=t,this.message=i;const o=new Error(i).stack;o!==void 0&&(this.stack=`${this.toString()}
${o.replace(/^Error(:[^\n]*)?\n/,"")}`)});return r.prototype=Object.create(e.prototype),r.prototype.constructor=r,r.prototype.toString=function(){return this.message===void 0?this.name:`${this.name}: ${this.message}`},r}let K;function h(e){throw new K(e)}let Tt;function Oe(e){throw new Tt(e)}function Z(e,t,r){e.forEach(s=>{we[s]=t});function i(s){const l=r(s);l.length!==e.length&&Oe("Mismatched type converter count");for(let d=0;d<e.length;++d)C(e[d],l[d])}const o=new Array(t.length),a=[];let u=0;t.forEach((s,l)=>{W.hasOwnProperty(s)?o[l]=W[s]:(a.push(s),J.hasOwnProperty(s)||(J[s]=[]),J[s].push(()=>{o[l]=W[s],++u,u===a.length&&i(o)}))}),a.length===0&&i(o)}function C(e,t,r){if(r=r||{},!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");const i=t.name;if(e||h(`type "${i}" must have a positive integer typeid pointer`),W.hasOwnProperty(e)){if(r.ignoreDuplicateRegistrations)return;h(`Cannot register type '${i}' twice`)}if(W[e]=t,delete we[e],J.hasOwnProperty(e)){const o=J[e];delete J[e],o.forEach(a=>{a()})}}function Pn(e,t,r,i,o){const a=Ie(r);t=A(t),C(e,{name:t,fromWireType(u){return!!u},toWireType(u,s){return s?i:o},argPackAdvance:8,readValueFromPointer(u){let s;if(r===1)s=z;else if(r===2)s=De;else if(r===4)s=F;else throw new TypeError(`Unknown boolean type size: ${t}`);return this.fromWireType(s[u>>a])},destructorFunction:null})}function An(e){if(!(this instanceof X)||!(e instanceof X))return!1;let t=this.$$.ptrType.registeredClass,r=this.$$.ptr,i=e.$$.ptrType.registeredClass,o=e.$$.ptr;for(;t.baseClass;)r=t.upcast(r),t=t.baseClass;for(;i.baseClass;)o=i.upcast(o),i=i.baseClass;return t===i&&r===o}function Fn(e){return{count:e.count,deleteScheduled:e.deleteScheduled,preservePointerOnDelete:e.preservePointerOnDelete,ptr:e.ptr,ptrType:e.ptrType,smartPtr:e.smartPtr,smartPtrType:e.smartPtrType}}function xe(e){function t(r){return r.$$.ptrType.registeredClass.name}h(`${t(e)} instance already deleted`)}let Xe=!1;function Et(e){}function Mn(e){e.smartPtr?e.smartPtrType.rawDestructor(e.smartPtr):e.ptrType.registeredClass.rawDestructor(e.ptr)}function gt(e){e.count.value-=1,e.count.value===0&&Mn(e)}function le(e){return typeof FinalizationGroup>"u"?(le=function(t){return t},e):(Xe=new FinalizationGroup(t=>{for(let r=t.next();!r.done;r=t.next()){const i=r.value;i.ptr?gt(i):console.warn(`object already deleted: ${i.ptr}`)}}),le=function(t){return Xe.register(t,t.$$,t.$$),t},Et=function(t){Xe.unregister(t.$$)},le(e))}function Sn(){if(this.$$.ptr||xe(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;const e=le(Object.create(Object.getPrototypeOf(this),{$$:{value:Fn(this.$$)}}));return e.$$.count.value+=1,e.$$.deleteScheduled=!1,e}function Dn(){this.$$.ptr||xe(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&h("Object already scheduled for deletion"),Et(this),gt(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function vn(){return!this.$$.ptr}let fe;const de=[];function ke(){for(;de.length;){const e=de.pop();e.$$.deleteScheduled=!1,e.delete()}}function $n(){return this.$$.ptr||xe(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&h("Object already scheduled for deletion"),de.push(this),de.length===1&&fe&&fe(ke),this.$$.deleteScheduled=!0,this}function In(){X.prototype.isAliasOf=An,X.prototype.clone=Sn,X.prototype.delete=Dn,X.prototype.isDeleted=vn,X.prototype.deleteLater=$n}function X(){}const mt={};function wt(e,t,r){if(e[t].overloadTable===void 0){const i=e[t];e[t]=function(){return e[t].overloadTable.hasOwnProperty(arguments.length)||h(`Function '${r}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`),e[t].overloadTable[arguments.length].apply(this,arguments)},e[t].overloadTable=[],e[t].overloadTable[i.argCount]=i}}function Ot(e,t,r){n.hasOwnProperty(e)?((r===void 0||n[e].overloadTable!==void 0&&n[e].overloadTable[r]!==void 0)&&h(`Cannot register public name '${e}' twice`),wt(n,e,e),n.hasOwnProperty(r)&&h(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`),n[e].overloadTable[r]=t):(n[e]=t,r!==void 0&&(n[e].numArguments=r))}function Cn(e,t,r,i,o,a,u,s){this.name=e,this.constructor=t,this.instancePrototype=r,this.rawDestructor=i,this.baseClass=o,this.getActualType=a,this.upcast=u,this.downcast=s,this.pureVirtualFunctions=[]}function je(e,t,r){for(;t!==r;)t.upcast||h(`Expected null or instance of ${r.name}, got an instance of ${t.name}`),e=t.upcast(e),t=t.baseClass;return e}function Nn(e,t){if(t===null)return this.isReference&&h(`null is not a valid ${this.name}`),0;t.$$||h(`Cannot pass "${ee(t)}" as a ${this.name}`),t.$$.ptr||h(`Cannot pass deleted object as a pointer of type ${this.name}`);const r=t.$$.ptrType.registeredClass;return je(t.$$.ptr,r,this.registeredClass)}function Un(e,t){let r;if(t===null)return this.isReference&&h(`null is not a valid ${this.name}`),this.isSmartPointer?(r=this.rawConstructor(),e!==null&&e.push(this.rawDestructor,r),r):0;t.$$||h(`Cannot pass "${ee(t)}" as a ${this.name}`),t.$$.ptr||h(`Cannot pass deleted object as a pointer of type ${this.name}`),!this.isConst&&t.$$.ptrType.isConst&&h(`Cannot convert argument of type ${t.$$.smartPtrType?t.$$.smartPtrType.name:t.$$.ptrType.name} to parameter type ${this.name}`);const i=t.$$.ptrType.registeredClass;if(r=je(t.$$.ptr,i,this.registeredClass),this.isSmartPointer)switch(t.$$.smartPtr===void 0&&h("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:t.$$.smartPtrType===this?r=t.$$.smartPtr:h(`Cannot convert argument of type ${t.$$.smartPtrType?t.$$.smartPtrType.name:t.$$.ptrType.name} to parameter type ${this.name}`);break;case 1:r=t.$$.smartPtr;break;case 2:if(t.$$.smartPtrType===this)r=t.$$.smartPtr;else{const o=t.clone();r=this.rawShare(r,Qe(()=>{o.delete()})),e!==null&&e.push(this.rawDestructor,r)}break;default:h("Unsupporting sharing policy")}return r}function xn(e,t){if(t===null)return this.isReference&&h(`null is not a valid ${this.name}`),0;t.$$||h(`Cannot pass "${ee(t)}" as a ${this.name}`),t.$$.ptr||h(`Cannot pass deleted object as a pointer of type ${this.name}`),t.$$.ptrType.isConst&&h(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);const r=t.$$.ptrType.registeredClass;return je(t.$$.ptr,r,this.registeredClass)}function be(e){return this.fromWireType(P[e>>2])}function Xn(e){return this.rawGetPointee&&(e=this.rawGetPointee(e)),e}function kn(e){this.rawDestructor&&this.rawDestructor(e)}function jn(e){e!==null&&e.delete()}function bt(e,t,r){if(t===r)return e;if(r.baseClass===void 0)return null;const i=bt(e,t,r.baseClass);return i===null?null:r.downcast(i)}function Ln(){return Object.keys(pe).length}function Hn(){const e=[];for(const t in pe)pe.hasOwnProperty(t)&&e.push(pe[t]);return e}function Qn(e){fe=e,de.length&&fe&&fe(ke)}function Bn(){n.getInheritedInstanceCount=Ln,n.getLiveInheritedInstances=Hn,n.flushPendingDeletes=ke,n.setDelayFunction=Qn}var pe={};function Wn(e,t){for(t===void 0&&h("ptr should not be undefined");e.baseClass;)t=e.upcast(t),e=e.baseClass;return t}function Vn(e,t){return t=Wn(e,t),pe[t]}function Re(e,t){(!t.ptrType||!t.ptr)&&Oe("makeClassHandle requires ptr and ptrType");const r=!!t.smartPtrType,i=!!t.smartPtr;return r!==i&&Oe("Both smartPtrType and smartPtr must be specified"),t.count={value:1},le(Object.create(e,{$$:{value:t}}))}function Yn(e){const t=this.getPointee(e);if(!t)return this.destructor(e),null;const r=Vn(this.registeredClass,t);if(r!==void 0){if(r.$$.count.value===0)return r.$$.ptr=t,r.$$.smartPtr=e,r.clone();const l=r.clone();return this.destructor(e),l}function i(){return this.isSmartPointer?Re(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:t,smartPtrType:this,smartPtr:e}):Re(this.registeredClass.instancePrototype,{ptrType:this,ptr:e})}const o=this.registeredClass.getActualType(t),a=mt[o];if(!a)return i.call(this);let u;this.isConst?u=a.constPointerType:u=a.pointerType;const s=bt(t,this.registeredClass,u.registeredClass);return s===null?i.call(this):this.isSmartPointer?Re(u.registeredClass.instancePrototype,{ptrType:u,ptr:s,smartPtrType:this,smartPtr:e}):Re(u.registeredClass.instancePrototype,{ptrType:u,ptr:s})}function zn(){N.prototype.getPointee=Xn,N.prototype.destructor=kn,N.prototype.argPackAdvance=8,N.prototype.readValueFromPointer=be,N.prototype.deleteObject=jn,N.prototype.fromWireType=Yn}function N(e,t,r,i,o,a,u,s,l,d,_){this.name=e,this.registeredClass=t,this.isReference=r,this.isConst=i,this.isSmartPointer=o,this.pointeeType=a,this.sharingPolicy=u,this.rawGetPointee=s,this.rawConstructor=l,this.rawShare=d,this.rawDestructor=_,!o&&t.baseClass===void 0?i?(this.toWireType=Nn,this.destructorFunction=null):(this.toWireType=xn,this.destructorFunction=null):this.toWireType=Un}function Rt(e,t,r){n.hasOwnProperty(e)||Oe("Replacing nonexistant public symbol"),n[e].overloadTable!==void 0&&r!==void 0?n[e].overloadTable[r]=t:(n[e]=t,n[e].argCount=r)}function V(e,t){e=A(e);function r(o){const a=[];for(let l=1;l<e.length;++l)a.push(`a${l}`);let s=`return function ${`dynCall_${e}_${t}`}(${a.join(", ")}) {
`;return s+=`    return dynCall(rawFunction${a.length?", ":""}${a.join(", ")});
`,s+=`};
`,new Function("dynCall","rawFunction",s)(o,t)}let i;if(n[`FUNCTION_TABLE_${e}`]!==void 0)i=n[`FUNCTION_TABLE_${e}`][t];else if(typeof FUNCTION_TABLE<"u")i=FUNCTION_TABLE[t];else{let o=n[`dynCall_${e}`];o===void 0&&(o=n[`dynCall_${e.replace(/f/g,"d")}`],o===void 0&&h(`No dynCall invoker for signature: ${e}`)),i=r(o)}return typeof i!="function"&&h(`unknown function pointer with signature ${e}: ${t}`),i}let Pt;function At(e){const t=Xr(e),r=A(t);return v(t),r}function Pe(e,t){const r=[],i={};function o(a){if(!i[a]&&!W[a]){if(we[a]){we[a].forEach(o);return}r.push(a),i[a]=!0}}throw t.forEach(o),new Pt(`${e}: ${r.map(At).join([", "])}`)}function Gn(e,t,r,i,o,a,u,s,l,d,_,p,y){_=A(_),a=V(o,a),s&&(s=V(u,s)),d&&(d=V(l,d)),y=V(p,y);const O=Ce(_);Ot(O,()=>{Pe(`Cannot construct ${_} due to unbound types`,[i])}),Z([e,t,r],i?[i]:[],b=>{b=b[0];let $,Ae;i?($=b.registeredClass,Ae=$.instancePrototype):Ae=X.prototype;const Fe=Ne(O,function(){if(Object.getPrototypeOf(this)!==Y)throw new K(`Use 'new' to construct ${_}`);if(te.constructor_body===void 0)throw new K(`${_} has no accessible constructor`);const Ut=te.constructor_body[arguments.length];if(Ut===void 0)throw new K(`Tried to invoke ctor of ${_} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(te.constructor_body).toString()}) parameters instead!`);return Ut.apply(this,arguments)});var Y=Object.create(Ae,{constructor:{value:Fe}});Fe.prototype=Y;var te=new Cn(_,Fe,Y,y,$,a,s,d);const Hr=new N(_,te,!0,!1,!1),Ct=new N(`${_}*`,te,!1,!1,!1),Nt=new N(`${_} const*`,te,!1,!0,!1);return mt[e]={pointerType:Ct,constPointerType:Nt},Rt(O,Fe),[Hr,Ct,Nt]})}function Le(e,t){const r=[];for(let i=0;i<e;i++)r.push(F[(t>>2)+i]);return r}function Ft(e){for(;e.length;){const t=e.pop();e.pop()(t)}}function qn(e,t,r,i,o,a){const u=Le(t,r);o=V(i,o),Z([],[e],s=>{s=s[0];const l=`constructor ${s.name}`;if(s.registeredClass.constructor_body===void 0&&(s.registeredClass.constructor_body=[]),s.registeredClass.constructor_body[t-1]!==void 0)throw new K(`Cannot register multiple constructors with identical number of parameters (${t-1}) for class '${s.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);return s.registeredClass.constructor_body[t-1]=function(){Pe(`Cannot construct ${s.name} due to unbound types`,u)},Z([],u,d=>(s.registeredClass.constructor_body[t-1]=function(){arguments.length!==t-1&&h(`${l} called with ${arguments.length} arguments, expected ${t-1}`);const p=[],y=new Array(t);y[0]=a;for(let b=1;b<t;++b)y[b]=d[b].toWireType(p,arguments[b-1]);const O=o.apply(null,y);return Ft(p),d[0].fromWireType(O)},[])),[]})}function Jn(e,t){if(!(e instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof e} which is not a function`);const r=Ne(e.name||"unknownFunctionName",()=>{});r.prototype=e.prototype;const i=new r,o=e.apply(i,t);return o instanceof Object?o:i}function Mt(e,t,r,i,o){const a=t.length;a<2&&h("argTypes array size mismatch! Must at least get return value and 'this' types!");const u=t[1]!==null&&r!==null;let s=!1;for(var l=1;l<t.length;++l)if(t[l]!==null&&t[l].destructorFunction===void 0){s=!0;break}const d=t[0].name!=="void";let _="",p="";for(var l=0;l<a-2;++l)_+=`${l!==0?", ":""}arg${l}`,p+=`${l!==0?", ":""}arg${l}Wired`;let y=`return function ${Ce(e)}(${_}) {
if (arguments.length !== ${a-2}) {
throwBindingError('function ${e} called with ' + arguments.length + ' arguments, expected ${a-2} args!');
}
`;s&&(y+=`var destructors = [];
`);const O=s?"destructors":"null",b=["throwBindingError","invoker","fn","runDestructors","retType","classParam"],$=[h,i,o,Ft,t[0],t[1]];u&&(y+=`var thisWired = classParam.toWireType(${O}, this);
`);for(var l=0;l<a-2;++l)y+=`var arg${l}Wired = argType${l}.toWireType(${O}, arg${l}); // ${t[l+2].name}
`,b.push(`argType${l}`),$.push(t[l+2]);if(u&&(p=`thisWired${p.length>0?", ":""}${p}`),y+=`${d?"var rv = ":""}invoker(fn${p.length>0?", ":""}${p});
`,s)y+=`runDestructors(destructors);
`;else for(var l=u?1:2;l<t.length;++l){const Y=l===1?"thisWired":`arg${l-2}Wired`;t[l].destructorFunction!==null&&(y+=`${Y}_dtor(${Y}); // ${t[l].name}
`,b.push(`${Y}_dtor`),$.push(t[l].destructorFunction))}return d&&(y+=`var ret = retType.fromWireType(rv);
return ret;
`),y+=`}
`,b.push(y),Jn(Function,b).apply(null,$)}function Kn(e,t,r,i,o,a,u,s){const l=Le(r,i);t=A(t),a=V(o,a),Z([],[e],d=>{d=d[0];const _=`${d.name}.${t}`;s&&d.registeredClass.pureVirtualFunctions.push(t);function p(){Pe(`Cannot call ${_} due to unbound types`,l)}const y=d.registeredClass.instancePrototype,O=y[t];return O===void 0||O.overloadTable===void 0&&O.className!==d.name&&O.argCount===r-2?(p.argCount=r-2,p.className=d.name,y[t]=p):(wt(y,t,_),y[t].overloadTable[r-2]=p),Z([],l,b=>{const $=Mt(_,b,d,a,u);return y[t].overloadTable===void 0?($.argCount=r-2,y[t]=$):y[t].overloadTable[r-2]=$,[]}),[]})}const He=[],D=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function St(e){e>4&&--D[e].refcount===0&&(D[e]=void 0,He.push(e))}function Zn(){let e=0;for(let t=5;t<D.length;++t)D[t]!==void 0&&++e;return e}function er(){for(let e=5;e<D.length;++e)if(D[e]!==void 0)return D[e];return null}function tr(){n.count_emval_handles=Zn,n.get_first_emval=er}function Qe(e){switch(e){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{const t=He.length?He.pop():D.length;return D[t]={refcount:1,value:e},t}}}function nr(e,t){t=A(t),C(e,{name:t,fromWireType(r){const i=D[r].value;return St(r),i},toWireType(r,i){return Qe(i)},argPackAdvance:8,readValueFromPointer:be,destructorFunction:null})}function ee(e){if(e===null)return"null";const t=typeof e;return t==="object"||t==="array"||t==="function"?e.toString():`${e}`}function rr(e,t){switch(t){case 2:return function(r){return this.fromWireType(it[r>>2])};case 3:return function(r){return this.fromWireType(ot[r>>3])};default:throw new TypeError(`Unknown float type: ${e}`)}}function ir(e,t,r){const i=Ie(r);t=A(t),C(e,{name:t,fromWireType(o){return o},toWireType(o,a){if(typeof a!="number"&&typeof a!="boolean")throw new TypeError(`Cannot convert "${ee(a)}" to ${this.name}`);return a},argPackAdvance:8,readValueFromPointer:rr(t,i),destructorFunction:null})}function or(e,t,r,i,o,a){const u=Le(t,r);e=A(e),o=V(i,o),Ot(e,()=>{Pe(`Cannot call ${e} due to unbound types`,u)},t-1),Z([],u,s=>{const l=[s[0],null].concat(s.slice(1));return Rt(e,Mt(e,l,null,o,a),t-1),[]})}function ar(e,t,r){switch(t){case 0:return r?function(o){return z[o]}:function(o){return w[o]};case 1:return r?function(o){return De[o>>1]}:function(o){return ve[o>>1]};case 2:return r?function(o){return F[o>>2]}:function(o){return P[o>>2]};default:throw new TypeError(`Unknown integer type: ${e}`)}}function sr(e,t,r,i,o){t=A(t),o===-1&&(o=4294967295);const a=Ie(r);let u=function(l){return l};if(i===0){const l=32-8*r;u=function(d){return d<<l>>>l}}const s=t.indexOf("unsigned")!=-1;C(e,{name:t,fromWireType:u,toWireType(l,d){if(typeof d!="number"&&typeof d!="boolean")throw new TypeError(`Cannot convert "${ee(d)}" to ${this.name}`);if(d<i||d>o)throw new TypeError(`Passing a number "${ee(d)}" from JS side to C/C++ side to an argument of type "${t}", which is outside the valid range [${i}, ${o}]!`);return s?d>>>0:d|0},argPackAdvance:8,readValueFromPointer:ar(t,a,i!==0),destructorFunction:null})}function cr(e,t,r){const o=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][t];function a(u){u=u>>2;const s=P,l=s[u],d=s[u+1];return new o(s.buffer,d,l)}r=A(r),C(e,{name:r,fromWireType:a,argPackAdvance:8,readValueFromPointer:a},{ignoreDuplicateRegistrations:!0})}function ur(e,t){t=A(t);const r=t==="std::string";C(e,{name:t,fromWireType(i){const o=P[i>>2];let a;if(r){const s=w[i+4+o];let l=0;s!=0&&(l=s,w[i+4+o]=0);let d=i+4;for(var u=0;u<=o;++u){const _=i+4+u;if(w[_]==0){const p=L(d);a===void 0?a=p:(a+="\0",a+=p),d=_+1}}l!=0&&(w[i+4+o]=l)}else{const s=new Array(o);for(var u=0;u<o;++u)s[u]=String.fromCharCode(w[i+4+u]);a=s.join("")}return v(i),a},toWireType(i,o){Object.prototype.toString.call(o)==="[object ArrayBuffer]"&&(o=new Uint8Array(o));let a;const u=typeof o=="string";u||o instanceof Uint8Array||o instanceof Uint8ClampedArray||o instanceof Int8Array||h("Cannot pass non-string to std::string"),r&&u?a=function(){return tt(o)}:a=function(){return o.length};const s=a(),l=_e(4+s+1);if(P[l>>2]=s,r&&u)ge(o,l+4,s+1);else if(u)for(var d=0;d<s;++d){const _=o.charCodeAt(d);_>255&&(v(l),h("String has UTF-16 code units that do not fit in 8 bits")),w[l+4+d]=_}else for(var d=0;d<s;++d)w[l+4+d]=o[d];return i!==null&&i.push(v,l),l},argPackAdvance:8,readValueFromPointer:be,destructorFunction(i){v(i)}})}function lr(e,t,r){r=A(r);let i,o;t===2?(i=function(){return ve},o=1):t===4&&(i=function(){return P},o=2),C(e,{name:r,fromWireType(a){const u=i(),s=P[a>>2],l=new Array(s),d=a+4>>o;for(let _=0;_<s;++_)l[_]=String.fromCharCode(u[d+_]);return v(a),l.join("")},toWireType(a,u){const s=u.length,l=_e(4+s*t),d=i();P[l>>2]=s;const _=l+4>>o;for(let p=0;p<s;++p)d[_+p]=u.charCodeAt(p);return a!==null&&a.push(v,l),l},argPackAdvance:8,readValueFromPointer:be,destructorFunction(a){v(a)}})}function fr(e,t){t=A(t),C(e,{isVoid:!0,name:t,argPackAdvance:0,fromWireType(){},toWireType(r,i){}})}function dr(e){e>4&&(D[e].refcount+=1)}function pr(e,t){const r=W[e];return r===void 0&&h(`${t} has unknown type ${At(e)}`),r}function _r(e,t){e=pr(e,"_emval_take_value");const r=e.readValueFromPointer(t);return Qe(r)}function yr(){c()}function Dt(){return z.length}function hr(e){try{return j.grow(e-H.byteLength+65535>>16),at(j.buffer),1}catch(t){console.error(`emscripten_realloc_buffer: Attempted to grow heap from ${H.byteLength} bytes to ${e} bytes, but got error: ${t}`)}}function Tr(e){const t=Dt();f(e>t);const r=65536,i=2147483648-r;if(e>i)return m(`Cannot enlarge memory, asked to go up to ${e} bytes, but the limit is ${i} bytes!`),!1;let a=Math.max(t,16777216);for(;a<e;)a<=536870912?a=rt(2*a,r):a=Math.min(rt((3*a+2147483648)/4,r),i),a===t&&I(`Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ${z.length}`);return hr(a)?!0:(m(`Failed to grow the heap from ${t} bytes to ${a} bytes, not enough memory!`),!1)}function Er(e){Lr(e)}function gr(e){return Math.log(e)/Math.LN2}function mr(e){return gr(e)}function wr(){c("trap!")}function Or(e,t,r){w.set(w.subarray(t,t+r),e)}On(),K=n.BindingError=Ue(Error,"BindingError"),Tt=n.InternalError=Ue(Error,"InternalError"),In(),zn(),Bn(),Pt=n.UnboundTypeError=Ue(Error,"UnboundTypeError"),tr();function br(e){R(e,"i")}function Rr(e){R(e,"ii")}function Pr(e){R(e,"iidiiii")}function Ar(e){R(e,"iii")}function Fr(e){R(e,"iiii")}function Mr(e){R(e,"iiiii")}function Sr(e){R(e,"jiji")}function Dr(e){R(e,"v")}function vr(e){R(e,"vi")}function $r(e){R(e,"vii")}function Ir(e){R(e,"viii")}function Cr(e){R(e,"viiii")}function Nr(e){R(e,"viiiii")}function Ur(e){R(e,"viiiiii")}const xr={};var Be={___assert_fail:ln,___cxa_allocate_exception:fn,___cxa_throw:dn,___lock:pn,___unlock:_n,___wasi_fd_close:hn,___wasi_fd_seek:En,___wasi_fd_write:wn,__embind_register_bool:Pn,__embind_register_class:Gn,__embind_register_class_constructor:qn,__embind_register_class_function:Kn,__embind_register_emval:nr,__embind_register_float:ir,__embind_register_function:or,__embind_register_integer:sr,__embind_register_memory_view:cr,__embind_register_std_string:ur,__embind_register_std_wstring:lr,__embind_register_void:fr,__emval_decref:St,__emval_incref:dr,__emval_take_value:_r,__memory_base:1024,__table_base:0,_abort:yr,_emscripten_get_heap_size:Dt,_emscripten_memcpy_big:Or,_emscripten_resize_heap:Tr,_exit:Er,_llvm_log2_f64:mr,_llvm_trap:wr,abortStackOverflow:ut,memory:j,nullFunc_i:br,nullFunc_ii:Rr,nullFunc_iidiiii:Pr,nullFunc_iii:Ar,nullFunc_iiii:Fr,nullFunc_iiiii:Mr,nullFunc_jiji:Sr,nullFunc_v:Dr,nullFunc_vi:vr,nullFunc_vii:$r,nullFunc_viii:Ir,nullFunc_viiii:Cr,nullFunc_viiiii:Nr,nullFunc_viiiiii:Ur,setTempRet0:kt,table:jt};const vt=n.asm(xr,Be,H);n.asm=vt;var We=n.__ZSt18uncaught_exceptionv=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.__ZSt18uncaught_exceptionv.apply(null,arguments)};n.___cxa_demangle=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.___cxa_demangle.apply(null,arguments)},n.___embind_register_native_and_builtin_types=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.___embind_register_native_and_builtin_types.apply(null,arguments)};var Xr=n.___getTypeName=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.___getTypeName.apply(null,arguments)};n._fflush=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm._fflush.apply(null,arguments)};var v=n._free=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm._free.apply(null,arguments)},_e=n._malloc=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm._malloc.apply(null,arguments)};n.establishStackSpace=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.establishStackSpace.apply(null,arguments)};var kr=n.globalCtors=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.globalCtors.apply(null,arguments)},Ve=n.stackAlloc=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.stackAlloc.apply(null,arguments)},$t=n.stackRestore=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.stackRestore.apply(null,arguments)},Ye=n.stackSave=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.stackSave.apply(null,arguments)};n.dynCall_i=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_i.apply(null,arguments)},n.dynCall_ii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_ii.apply(null,arguments)},n.dynCall_iidiiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_iidiiii.apply(null,arguments)},n.dynCall_iii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_iii.apply(null,arguments)},n.dynCall_iiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_iiii.apply(null,arguments)},n.dynCall_iiiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_iiiii.apply(null,arguments)},n.dynCall_jiji=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_jiji.apply(null,arguments)},n.dynCall_v=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_v.apply(null,arguments)},n.dynCall_vi=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_vi.apply(null,arguments)},n.dynCall_vii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_vii.apply(null,arguments)},n.dynCall_viii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_viii.apply(null,arguments)},n.dynCall_viiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_viiii.apply(null,arguments)},n.dynCall_viiiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_viiiii.apply(null,arguments)},n.dynCall_viiiiii=function(){return f(T,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)"),f(!E,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"),n.asm.dynCall_viiiiii.apply(null,arguments)},n.asm=vt,Object.getOwnPropertyDescriptor(n,"intArrayFromString")||(n.intArrayFromString=function(){c("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"intArrayToString")||(n.intArrayToString=function(){c("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),n.ccall=Ke,n.cwrap=Ht,Object.getOwnPropertyDescriptor(n,"setValue")||(n.setValue=function(){c("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getValue")||(n.getValue=function(){c("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"allocate")||(n.allocate=function(){c("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getMemory")||(n.getMemory=function(){c("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"AsciiToString")||(n.AsciiToString=function(){c("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stringToAscii")||(n.stringToAscii=function(){c("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"UTF8ArrayToString")||(n.UTF8ArrayToString=function(){c("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"UTF8ToString")||(n.UTF8ToString=function(){c("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stringToUTF8Array")||(n.stringToUTF8Array=function(){c("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),n.stringToUTF8=ge,Object.getOwnPropertyDescriptor(n,"lengthBytesUTF8")||(n.lengthBytesUTF8=function(){c("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"UTF16ToString")||(n.UTF16ToString=function(){c("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stringToUTF16")||(n.stringToUTF16=function(){c("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"lengthBytesUTF16")||(n.lengthBytesUTF16=function(){c("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"UTF32ToString")||(n.UTF32ToString=function(){c("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stringToUTF32")||(n.stringToUTF32=function(){c("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"lengthBytesUTF32")||(n.lengthBytesUTF32=function(){c("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"allocateUTF8")||(n.allocateUTF8=function(){c("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stackTrace")||(n.stackTrace=function(){c("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addOnPreRun")||(n.addOnPreRun=function(){c("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addOnInit")||(n.addOnInit=function(){c("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addOnPreMain")||(n.addOnPreMain=function(){c("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addOnExit")||(n.addOnExit=function(){c("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addOnPostRun")||(n.addOnPostRun=function(){c("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"writeStringToMemory")||(n.writeStringToMemory=function(){c("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"writeArrayToMemory")||(n.writeArrayToMemory=function(){c("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"writeAsciiToMemory")||(n.writeAsciiToMemory=function(){c("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addRunDependency")||(n.addRunDependency=function(){c("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"removeRunDependency")||(n.removeRunDependency=function(){c("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"ENV")||(n.ENV=function(){c("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"FS")||(n.FS=function(){c("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"FS_createFolder")||(n.FS_createFolder=function(){c("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createPath")||(n.FS_createPath=function(){c("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createDataFile")||(n.FS_createDataFile=function(){c("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createPreloadedFile")||(n.FS_createPreloadedFile=function(){c("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createLazyFile")||(n.FS_createLazyFile=function(){c("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createLink")||(n.FS_createLink=function(){c("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_createDevice")||(n.FS_createDevice=function(){c("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"FS_unlink")||(n.FS_unlink=function(){c("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}),Object.getOwnPropertyDescriptor(n,"GL")||(n.GL=function(){c("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"dynamicAlloc")||(n.dynamicAlloc=function(){c("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"loadDynamicLibrary")||(n.loadDynamicLibrary=function(){c("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"loadWebAssemblyModule")||(n.loadWebAssemblyModule=function(){c("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getLEB")||(n.getLEB=function(){c("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getFunctionTables")||(n.getFunctionTables=function(){c("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"alignFunctionTables")||(n.alignFunctionTables=function(){c("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"registerFunctions")||(n.registerFunctions=function(){c("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"addFunction")||(n.addFunction=function(){c("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"removeFunction")||(n.removeFunction=function(){c("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getFuncWrapper")||(n.getFuncWrapper=function(){c("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"prettyPrint")||(n.prettyPrint=function(){c("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"makeBigInt")||(n.makeBigInt=function(){c("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"dynCall")||(n.dynCall=function(){c("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getCompilerSetting")||(n.getCompilerSetting=function(){c("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stackSave")||(n.stackSave=function(){c("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stackRestore")||(n.stackRestore=function(){c("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"stackAlloc")||(n.stackAlloc=function(){c("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"establishStackSpace")||(n.establishStackSpace=function(){c("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"print")||(n.print=function(){c("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"printErr")||(n.printErr=function(){c("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"getTempRet0")||(n.getTempRet0=function(){c("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"setTempRet0")||(n.setTempRet0=function(){c("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"callMain")||(n.callMain=function(){c("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"abort")||(n.abort=function(){c("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"Pointer_stringify")||(n.Pointer_stringify=function(){c("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),Object.getOwnPropertyDescriptor(n,"warnOnce")||(n.warnOnce=function(){c("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}),n.writeStackCookie=ct,n.checkStackCookie=q,n.abortStackOverflow=ut,Object.getOwnPropertyDescriptor(n,"ALLOC_NORMAL")||Object.defineProperty(n,"ALLOC_NORMAL",{configurable:!0,get(){c("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}}),Object.getOwnPropertyDescriptor(n,"ALLOC_STACK")||Object.defineProperty(n,"ALLOC_STACK",{configurable:!0,get(){c("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}}),Object.getOwnPropertyDescriptor(n,"ALLOC_DYNAMIC")||Object.defineProperty(n,"ALLOC_DYNAMIC",{configurable:!0,get(){c("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}}),Object.getOwnPropertyDescriptor(n,"ALLOC_NONE")||Object.defineProperty(n,"ALLOC_NONE",{configurable:!0,get(){c("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}}),Object.getOwnPropertyDescriptor(n,"calledRun")||Object.defineProperty(n,"calledRun",{configurable:!0,get(){c("'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")}});let ye;n.then=function(e){if(ye)e(n);else{const t=n.onRuntimeInitialized;n.onRuntimeInitialized=function(){t&&t(),e(n)}}return n};function It(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}ce=function e(){ye||ze(),ye||(ce=e)};function ze(e){if(Q>0||(ct(),zt(),Q>0))return;function t(){ye||(ye=!0,!Ee&&(Gt(),qt(),n.onRuntimeInitialized&&n.onRuntimeInitialized(),f(!n._main,'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'),Kt()))}n.setStatus?(n.setStatus("Running..."),setTimeout(()=>{setTimeout(()=>{n.setStatus("")},1),t()},1)):t(),q()}n.run=ze;function jr(){const e=oe,t=m;let r=!1;oe=m=function(i){r=!0};try{const i=gn;i&&i(0)}catch{}oe=e,m=t,r&&(I("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc."),I("(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)"))}function Lr(e,t){jr(),Se?m(`program exited (with status: ${e}), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)`):(Ee=!0,Jt(),n.onExit&&n.onExit(e)),he(e,new It(e))}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);n.preInit.length>0;)n.preInit.pop()();return Se=!0,ze(),n}}();export{Br as default};
//# sourceMappingURL=woff2.bindings-C7e1KYUX.js.map
